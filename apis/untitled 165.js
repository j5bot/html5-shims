var html5shims=(function InitHtml5Shims(globalScope) {

    function Html5Shims() {
        this.path = globalScope['html5-shims.baseURL'];
        delete globalScope['html5-shims.baseURL'];
        this.lazyLoadingQueue = [];
        this.scripts = {InitHtml5Shims:InitHtml5Shims};
        this.prototype = this.constructor.prototype;
    }

    var html5shims = new Html5Shims;
    Html5Shims.prototype.status = {IDLE:0, LOADING:1, READY:3};
    Html5Shims.prototype.attach = function () {with (globalScope) {if (Html5Shims.prototype.Worker) {Worker = Html5Shims.prototype.Worker;}}};
    Html5Shims.prototype.lazyLoadShim = function (name, source, isObject) {var llqRef = this.lazyLoadingQueue.push({name:name, source:source, status:this.status.IDLE});var hs = this;return function () {hs.loadShim(name, source);if (isObject) {var o = new Object;o.constructor = hs[name];hs[name].prototype.constructor.apply(o, arguments);return o;}};};
    Html5Shims.prototype.loadShim = function (name, source) {var hs = this;this.load(name, source);return hs[name];};
    Html5Shims.prototype.load = function (name, source) {if (!this.scripts[name]) {var xhr = new XMLHttpRequest;xhr.open("GET", this.path + source, false);xhr.send(null);this.scripts[name] = xhr.responseText;}Html5Shims.prototype[name] = Function("html5shims", "globalScope", this.scripts[name])(this, globalScope);};
    Html5Shims.prototype.escapeQuotes = function (s) {return s.replace(/\\/gi, "\\\\").replace(/\'/gi, "\\'").replace(/\n/gi, "\\n");};
    Html5Shims.prototype.toSource = function (t) {if (t.toSource) {return t.toSource();}var s = [];for (var p in t) {s.push("'" + p + "':'" + t[p].toString() + "'");}return "{" + s.join(",") + "}";};
    if (typeof globalScope.Worker === "undefined" ||
        globalScope.Worker.prototype.constructor === globalScope.Worker) {
        Html5Shims.prototype.Worker = html5shims.lazyLoadShim("Worker", "/apis/DedicatedWorker.js", true);
    }
    html5shims.attach();
    return html5shims;
})(this);
var navigator = ({appName:"Netscape", appVersion:"5.0 (Macintosh; en-US)", platform:"MacIntel", userAgent:"Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1.12) Gecko/20080201 Firefox/2.0.0.12"});
navigator.online=true;
html5shims.scripts.WorkerGlobalScope='/*\n        Copyright 2009 Jonathan \'J5\' Cook \n        Licensed under the Apache License, Version 2.0 (the "License"); \n        you may not use this file except in compliance with the License. \n        You may obtain a copy of the License at \n        http://www.apache.org/licenses/LICENSE-2.0 Unless required \n        by applicable law or agreed to in writing, software distributed \n        under the License is distributed on an "AS IS" BASIS, WITHOUT \n        WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n        See the License for the specific language governing permissions \n        and limitations under the License.\n*/\nfunction WorkerGlobalScope (url) {\n	/* hide scope definition */\n    DedicatedWorkerGlobalScope = SharedWorkerGlobalScope = WorkerGlobalScope = undefined;\n\n    /* WorkerGlobalScope abstract interface */\n    /* readonly attribute WorkerGlobalScope */\n    this.self = this;\n\n    /* readonly attribute WorkerLocation */\n    this.location = new WorkerLocation(url);\n\n    /* attribute Function onerror */\n    this.onerror = function() {};\n\n    /* interface WorkerUtils */\n    /* readonly attribute Navigator navigator\n    \n    ATTRIBUTE IS INITIALIZED AFTER CONSTRUCTOR IS RUN\n    */\n    this.navigator = null;\n    \n    /* this flag is set by the close method to TRUE, at which time no further events can be queued */\n    /*\n    Each WorkerGlobalScope object also has a closing flag, which must initially be false, but which can get set to true by the algorithms in the processing model section below.\n\n    Once the WorkerGlobalScope\'s closing flag is set to true, the event loop\'s task queues must discard any further tasks that would be added to them\n    (tasks already on the queue are unaffected unless otherwise specified).\n    \n    Effectively, once the closing flag is true, timers stop firing, notifications for all pending asynchronous operations are dropped, etc.\n    */\n    this.closing = false;\n    \n    /* Ports owned by WorkerGlobalScope, which are entangled with other workers or with the "parent" */\n    /*\n    Each WorkerGlobalScope worker global scope has a list of the worker\'s ports, which consists of all the MessagePort objects that are entangled with another port\n    and that have one (but only one) port owned by worker global scope. This list includes  the implicit MessagePort in the case of dedicated workers.\n    */\n    this._ports = [];\n    \n    /* Workers spawned by WorkerGlobalScope, i.e. in which this worker is the "parent" */\n    /*\n    Each WorkerGlobalScope also has a list of the worker\'s workers. Initially this list is empty; it is populated when the worker creates or obtains further workers.\n    */\n    this._workers = {};\n    \n    /* Documents known to this worker */\n    /*\n    Finally, each WorkerGlobalScope also has a list of the worker\'s Documents. Initially this list is empty; it is populated when the worker is created.\n\n    Whenever a Document d is added to the worker\'s Documents, the user agent must, for each worker in the list of the worker\'s workers\n    whose list of the worker\'s Documents does not contain d, add d to q\'s WorkerGlobalScope owner\'s list of the worker\'s Documents.\n\n    Whenever a Document object is discarded, it must be removed from the list of the worker\'s Documents of each worker whose list contains that Document.\n    \n    WTF::: when importScript loads a document into the workerglobalscope, for each sub-worker that does not already have the document loaded, do something?\n    I think this has to do with knowing what scripts are running, where\n    */\n    this._documents = [];\n    \n    /* cache of scripts to be loaded via importScripts */\n    this._scripts = {};\n\n	/* message queue */\n	this._queue = [];\n    \n    this._parent = null;\n\n	this._ready = false;\n    \n    /* simple implementation of the entanglement without using ports */\n    this._wp = html5shims.entangleGearsWorkerPool(this);\n    \n    /* debug code: throw new Error("wgs handler: " + this.wom); */\n}\n\nfunction DedicatedWorkerGlobalScope (url) {\n    \n    var t = new WorkerGlobalScope(url);\n    \n	t.postMessage = function (message, ports) {\n	    /*\n	    DedicatedWorkerGlobalScope objects act as if they had an implicit MessagePort associated with them. This port is part of a channel that is set up when the worker is created, but it is not exposed. This object must never be garbage collected before the DedicatedWorkerGlobalScope object.\n\n	    All messages received by that port must immediately be retargeted at the DedicatedWorkerGlobalScope object.\n\n	    The postMessage() method on DedicatedWorkerGlobalScope objects must act as if, when invoked, it immediately invoked the method of the same name on the port, with the same arguments, and returned the same return value.\n	    */\n		if (this._parent !== null) {\n	    	this._wp.sendMessage(message,this._parent);\n		} else {\n			throw new Error("tried to send message (" + msg + ") without having parent");\n		}\n	};\n	\n    /* attribute Function onmessage */\n    t.onmessage = function (msg) {\n		if (!this._ready) {\n			this._queue.push(msg);\n		}\n	};\n    \n    return t;\n}\n\nfunction SharedWorkerGlobalScope (url, name) {\n    \n    var t = new WorkerGlobalScope(url);\n    \n    t.name = name;\n    t.applicationCache = new ApplicationCache();\n    \n    /* ports connect to worker scope through connect event */\n    t.onconnect = function () {};\n    \n    return t;\n}\n\nfunction WorkerLocation(url){\n    /* URL is expanded to full path by DedicatedWorker constructor */\n    var m = /^([^:]+):\\/\\/([^\\/]*)([^\\?#]+)(\\?([^#]*))?(#(.*))?$/.exec(this.href = "" + url);\n    /*\n    if(m === null)\n        throw new Error("Invalid URL");\n    */\n    if (m === null) { return false; }\n    this.protocol = m[1] + ":";\n    this.host = m[2] || "";\n    this.pathname = m[3] || "";\n    this.search = m[5] ? m[4] : "";\n    this.hash = m[7] ? m[6] : "";\n    m = this.host.split(":");\n    this.hostname = m[0];\n    this.port = m[1] || "";\n    this.toString = function() { return url; };\n}\n\n/*\nNavigator implements NavigatorID;\nNavigator implements NavigatorOnLine;\n\n[Supplemental, NoInterfaceObject]\ninterface NavigatorID {\n  readonly attribute DOMString appName;\n  readonly attribute DOMString appVersion;\n  readonly attribute DOMString platform;\n  readonly attribute DOMString userAgent;\n};\n\n[Supplemental, NoInterfaceObject]\ninterface NavigatorOnLine {\n  readonly attribute boolean onLine;\n};\n\n*/\n/* added after object construction, now\nfunction Navigator() {\n    this.appName = "";\n    this.appVersion = "";\n    this.platform = "";\n    this.userAgent = "";\n    this.onLine = true;\n}\n*/\n\n/* TODO */\nfunction ApplicationCache() {\n    \n}\n\nSharedWorkerGlobalScope.prototype = DedicatedWorkerGlobalScope.prototype = WorkerGlobalScope.prototype = {\n    /* private, implementation specific methods */\n	/* mark that the worker is started, and dequeue any messages waiting */\n	_start: function() {\n		this._ready = true;\n		var queuelength = this._queue.length;\n		/* dequeue messages that are waiting */\n		while (this._queue.length > 0) {\n			var m = this._queue[0];\n			this._queue = this._queue.slice(1);\n			this.onmessage(m);\n		}\n		// throw new Error("worker started with queue length: " + queuelength);\n	},\n\n    /* Execute the given code in the worker global scope (using with) */\n    _execute: function(source) {\n        /* debugging code: this.self.postMessage(source.toSource()); */\n        /* executing an empty script will throw an error ... when we find an empty script we put a comment in there */\n        if (source.length===0) { throw new Error("empty source provided, cannot executed"); }\n        Function("with(this) { " + source + " } ").call(this);\n    },\n    \n    _loadSource: function(options) {\n        \n        /* variable declarations */\n        var urls = options.url.slice ? options.url : [options.url],\n            callback = options.callback,\n            scripts = {},\n            inprogress = true,\n        \n            XMLHttpRequest = this.XMLHttpRequest,\n            re = /importScripts\\(["\']{1}([^"\']*)["\']{1}\\)/mig,\n			funcre = /^\\s*function\\s([^\\s(]*)\\(/mig,\n			funcreplace = "$1=function (",\n            location = this.location;\n\n        function loadMore () {\n            if (urls.length === 0) {\n                if (!inprogress) {\n                    callback(scripts);\n                }\n            } else {\n                /* gears Array doesn\'t have shift */\n                var l = urls[0];\n                urls = urls.slice(1);\n                load(l);\n            }\n        }\n\n        function test (source) {\n            var scripts = [];\n            var matches = re.exec(source);\n            while (matches !== null) {\n                scripts.push(matches[1]);\n                matches = re.exec(source);\n            }\n            urls = urls.concat(scripts);\n        }\n        \n        /* return the "absolute" version of the given URL */\n        function absolute(url) {\n            return url.charAt(0)==="/" ? location.href.split("/")[0]+url : (url.indexOf(":")!=-1 ? url : location.href.substring(0,location.href.lastIndexOf("/")+1) + url);\n        }\n\n        function load (url) {\n            if (!scripts[url]) {\n                if (urls.length===0 && inprogress) { inprogress = false; }\n                var xhr = new XMLHttpRequest();\n                xhr.open("get",absolute(url),true);\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState===4) {\n                        if (xhr.responseText.length!==0) {\n                            scripts[url]={source: xhr.responseText.replace(funcre,funcreplace), loaded: true};\n                            test(xhr.responseText);\n                            } else {\n                            scripts[url]={source:"/* empty script */", loaded: true};\n                        }\n                        loadMore();\n                    }\n                };\n                xhr.send();\n            } else {\n                loadMore();\n            }\n        }\n        \n        /* debugging code: throw new Error("shift: " + typeof(urls.shift) + ", slice: " + typeof(urls.slice)); */\n        \n        loadMore();\n    },\n    \n    _timerMethod: function(method) {\n        if (typeof this._timer === "undefined") {\n            this._timer = google.gears.factory.create("beta.timer");\n        }\n        /* can\'t use apply here because gears timer object doesn\'t implement it */\n        return arguments.length == 2 ? this._timer[method](arguments[1]) : this._timer[method](arguments[1],arguments[2]);\n    },\n    \n    /* WorkerGlobalScope abstract interface */\n    /* void close() */\n    /*\n        When a script invokes the close()  method on a WorkerGlobalScope object, the user agent must run the following steps (atomically):\n           1. Discard any tasks that have been added to the event loop\'s task queues.\n           2. Set the worker\'s WorkerGlobalScope object\'s closing flag to true. (This prevents any further tasks from being queued.)\n           3. Disentangle all the ports in the list of the worker\'s ports.\n    */\n    close: function () {\n        this.closing = true;\n    },\n\n    /* interface WorkerUtils */\n    /* void importScripts (in DOMString... url) */\n    importScripts: function () {\n    /* import the script(s) and then execute it in the worker global scope, in order, synchronously */\n        /*\n        Set the script\'s global object to worker global scope.\n\n        Set the script\'s browsing context to owner browsing context.\n\n        Set the script\'s URL character encoding to UTF-8. (This is just used for encoding non-ASCII characters in the query component of URLs.)\n\n        Set the script\'s base URL to url.\n        */\n        /* the script is read from a cache generated when the WorkerGlobalScope is created */\n        for(var i = 0, length = arguments.length; i < length; ++i) {\n            this._execute(this._scripts[ arguments[i] ].source);\n        }\n    },  \n    \n    /* Implements TimerUtils */\n    setTimeout: function (f,t) {\n        return this._timerMethod("setTimeout",f,t);\n    },\n\n    setInterval: function (f,t) {\n        return this._timerMethod("setInterval",f,t);\n    },\n\n    clearTimeout: function (f) {\n        return this._timerMethod("clearTimeout",f);\n    },\n\n    clearInterval: function (f) {\n        return this._timerMethod("clearInterval",f);\n    },\n\n    /* Other available APIs */\n    openDatabase: function () {\n    \n    },\n\n    openDatabaseSync: function () {\n        \n    },\n    \n    /* the shim for XHR */\n    XMLHttpRequest: function() {\n        /* flag whether synchronous request is supported */\n        var xhr, syncable = true, _async = true, t = this;\n        /* get the available XHR object */\n        if (typeof window === "undefined") {\n            xhr = google.gears.factory.create("beta.httprequest");\n            syncable = false;\n        } else if (typeof ActiveXObject === "undefined") {\n            if (typeof XMLHttpRequest != "undefined") {\n                xhr = new XMLHttpRequest();\n            } else {\n                xhr = new ActiveXObject("Microsoft.XMLHTTP");\n            }\n        }\n        \n        /* here we can redefine the XHR methods if needed, but I had no success with implementing synchronous call this way */\n        \n        return xhr;\n    },\n    \n    /*\n    WebSocket\n    MessageChannel\n    EventSource\n    */\n    \n    /* this will be overwritten by the parent\'s implementation */\n    Worker: function () {\n        \n    },\n    \n    SharedWorker: function () {\n    /* the implementation of SharedWorker is not started */\n    }\n};\n\nvar prototype = html5shims.prototype;\nprototype.DedicatedWorkerGlobalScope = DedicatedWorkerGlobalScope;\nprototype.SharedWorkerGlobalScope = SharedWorkerGlobalScope;\nprototype.WorkerGlobalScope = WorkerGlobalScope;\n\nreturn WorkerGlobalScope;';
html5shims.scripts.Worker='// we need to load up the APIs that are available inside the worker\nhtml5shims.loadShim("WorkerGlobalScope","/apis/WorkerGlobalScope.js");\nhtml5shims._workers = html5shims._workers || {};\n\n// clone the parts of the global scope navigator object that we need for WorkerGlobalScope\nvar navigator = {\n	appName: globalScope.navigator.appName,\n	appVersion: globalScope.navigator.appVersion,\n	platform: globalScope.navigator.platform,\n	userAgent: globalScope.navigator.userAgent\n};\n\nif (google && google.gears) {\n	if (google.gears.factory.getPermission("HTML5 Web Worker Emulator",null,"We use Google Gears to emulate the HTML5 Web Worker API and provide a faster experience for you.")) {\n		// not sure what to do here ... this is just giving us the permissions, really\n	}\n}\n\nhtml5shims.prototype.entangleGearsWorkerPool = function (globalScope) {\n	var isInner = !!google.gears.workerPool;\n	var wp = google.gears.workerPool || google.gears.factory.create("beta.workerpool");\n	var workers = html5shims._workers;\n	\n	// this is the "final" message handler, we\'ll hold a closure for it so that we can reference it from a temporary handler later\n	var wom = function(a,b,msg) {\n        /* message coming from a child worker */\n        if (workers && workers["w"+msg.sender]) {\n            /* set the worker to ready after ack */\n            if (msg.body==="{{ack}}") {\n				with (workers["w"+msg.sender]) {\n					_ready = true;\n					/* dequeue messages waiting to be sent to child worker */\n					while (_queue.length > 0) {\n						var mo = _queue[0];\n						_queue = _queue.slice(1);							\n						postMessage(mo);\n					}\n				}\n            } else {\n                workers["w"+msg.sender].onmessage({data:msg.body});\n            }\n        } else if (msg.sender === globalScope._parent){\n        	/* message coming from the parent */\n            globalScope.onmessage({data:msg.body});\n        } else {\n            /*\n            message is not from a parent or child worker\n            each "port" is only available to the Worker and the WorkerGlobalScope -- i.e. all messages\n            must go through parent-child MessagePort, they cannot go from grandchild to grandparent or from sibling to sibling\n            as may be possible in SharedWorker\n            */\n        }\n    };\n\n	wp.onmessage = !isInner ? wom : function (a,b,msg) {\n    	if (globalScope._parent === null && msg.body==="{{syn}}") {\n	        globalScope._parent = msg.sender;\n	        wp.sendMessage("{{ack}}",globalScope._parent);\n			wp.onmessage = wom;\n		}\n	};\n	\n	return wp;\n}\n\nfunction DedicatedWorker(url) {\n	this._ready = false;\n	this._queue = [];\n	\n	this.postMessage = function (o) {\n		/* debug code if (document) document.getElementById("demoworkers").innerHTML+=("this._id: " + this._id); */\n		if (this._wp && this._id !== null && this._ready) {\n			this._wp.sendMessage(o,this._id);\n		} else {\n			this._queue.push(o);\n		}\n	};\n	\n	url = url.charAt(0)==="/" ? globalScope.location.href.split("/")[0]+url : (url.indexOf(":")!=-1 ? url : globalScope.location.href.substring(0,globalScope.location.href.lastIndexOf("/")+1) + url);\n\n	this._source = [\n		"var html5shims=(" + html5shims.scripts["InitHtml5Shims"] + ")(this);",\n		"var navigator = " + html5shims.toSource(navigator)+";",\n		"navigator.online=true;",\n		"html5shims.scripts.WorkerGlobalScope=\'" + html5shims.escapeQuotes(html5shims.scripts.WorkerGlobalScope) + "\';",\n		"html5shims.scripts.Worker=\'" + html5shims.escapeQuotes(html5shims.scripts.Worker) + "\';",\n		"html5shims.loadShim(\'Worker\',\'/apis/DedicatedWorker.js\');",\n		"html5shims.loadShim(\'WorkerGlobalScope\',\'/apis/WorkerGlobalScope.js\');",\n		"html5shims.workerGlobalScope = html5shims.DedicatedWorkerGlobalScope(\\""+url+"\\");",\n		// "Worker=wgs.Worker=("+InitWorker+")(wgs,"+ html5shims.toSource(navigator) +",\'"+ html5shims.escapeQuotes(wgsSource)+"\');",\n		"html5shims.workerGlobalScope._loadSource({url: [\'" + url + "\'], "+\n		"callback: function(scripts){ html5shims.workerGlobalScope._scripts = scripts; html5shims.workerGlobalScope._execute(\'importScripts(\\""+url+"\\")\'); html5shims.workerGlobalScope._start(); } });"\n	].join("\\n");\n	\n	function defineOnMessageHandler() {\n		if (arguments.length > 0) {\n			delete this["onmessage"];\n			this.onmessage = arguments[0];\n		}\n		if (typeof this.onmessage === "undefined") {\n			throw new Error("undefined onmessage handler and worker to be created: " + url);\n		}\n		/* create the Gears worker process */\n		this._wp = html5shims.entangleGearsWorkerPool(this);\n		\n		this._ready = false;\n		this._id = this._wp.createWorker(this._source);\n		/* debug code workerPool.sendMessage("created gears worker: " + this._id,0); */\n		html5shims._workers["w"+this._id] = this;\n		/* upon receipt of this message, the WorkerGlobalScope will entangle with the worker and redefine it\'s onmessage method */\n		this._wp.sendMessage("{{syn}}",this._id);\n	}\n\n	/* we can only create the worker after the onmessage handler is defined\n	otherwise we may lose some messages */\n	/* for mozilla / opera / webkit / etc */\n	if (typeof document !== "undefined" && this.__defineSetter__) {\n			this.__defineSetter__("onmessage",function(val){ defineOnMessageHandler.call(this,val); });\n	/* for IE / others */\n	} else {\n		var t = this;\n		var interval = globalScope.setInterval(function(){ if (typeof t.onmessage != "undefined") { globalScope.clearInterval(interval); defineOnMessageHandler.call(t); } else { throw new Error("can\'t find onmessage"); }},1000);\n		delete t; delete interval;\n	}\n	return this;\n}\n\nreturn DedicatedWorker;';
html5shims.loadShim('Worker','/apis/DedicatedWorker.js');
html5shims.loadShim('WorkerGlobalScope','/apis/WorkerGlobalScope.js');
html5shims.workerGlobalScope = html5shims.DedicatedWorkerGlobalScope("http://html5-shims.googlecode.local/test/../workers/simplechild.js");
html5shims.workerGlobalScope._loadSource({url: ['http://html5-shims.googlecode.local/test/../workers/simplechild.js'], callback: function(scripts){ html5shims.workerGlobalScope._scripts = scripts; html5shims.workerGlobalScope._execute('importScripts("http://html5-shims.googlecode.local/test/../workers/simplechild.js")'); html5shims.workerGlobalScope._start(); } });